---
title: "Análisis de Curvas"
author: "Juan Carlos Bellassai"
date: "10/11/2021"
output: html_document
---


# Objetivo

Evaluar la curva resultante de aplicar un índice de similitud a una serie con distintos niveles de contaminación. 

```{r setup, include=FALSE}
setwd("C:/Users/Usuario/Google Drive (juancbellassai@mi.unc.edu.ar)/Juanc Doctorado/2021/Scrips/My_own_R_packages")
library(devtools)
load_all(".")
library(ggplot2)
```

# Dataset

El dataset a utilizar está compuesto por series de tiempo simuladas bajos los modelos AR(1), MA(1) y ARIMA. 

El dataset se encuentra en: https://drive.google.com/file/d/1FQQ9hMamyz568ar0amqRUki9-Q1pU46P/view?usp=sharing

```{r, warning=FALSE}
#Cargamos los datasets
setwd("C:/Users/Usuario/Google Drive (juancbellassai@mi.unc.edu.ar)/Juanc Doctorado/Base de datos/AR1-MA1-ARIMA_simulados")

fullAR1 = read.csv("AR1_TRAIN.csv")
fullMA1 = read.csv("Ma1_TRAIN.csv")
fullARIMA = read.csv("ARIMA_TRAIN.csv")
```

Vamos a seleccionar solo las primeras _n_ series de cada grupo y eliminamos la primera columna que corresponde a la etiqueta de clase. Cargamos los tres dataframes en una lista.

```{r}
nro.series = 10
df.list = list(AR=fullAR1[1:nro.series,-1], 
               MA=fullMA1[1:nro.series,-1], 
               ARIMA=fullARIMA[1:nro.series,-1]); names(df.list)
```

# Índices

Definimos qué índices vamos a comparar y los cargamos también en una lista.

```{r}
SSIMT <- function(X, Y, m){
  if (m=="median"){m=median()}
  if (m=="trim") {m=}
  #primero calculamos los elementos a utilizar para evitar carcularlos a cada rato
  #constante incluida para eliminar la inestabilidad que se da cuando las suma de las medias al cuadarado es muy proxima a cero
  C1 = 576e-6 # =(k1*L)^2  ; Por recomendacion del autor se toma k1=0.01 y L=2.4
  C2 = 5184e-6 # =(k2*L)^2 ; Por recomendacion del autor se toma k1=0.01 y L=2.4
  C3 = 2592e-6 # =c2/2
  muX = mean(X) 
  muY = mean(Y)
  vX = sd(X)
  vY = sd(Y)
  vXY = cov(X, Y)
  
  #relacion de luminancia
  l.xy = ((2 * abs(muX) * abs(muY)) + C1 ) / (muX^2 + muY^2 + C1)
  #relacion de contraste
  c.xy = ((2 * vX * vY) + C2 ) / (vX^2 + vY^2 + C2)
  #correlacion
  s.xy = (vXY + C3) / ((vX * vY) + C3)
  #calculamos la SSIM
  z = l.xy * c.xy * s.xy #asumimos los pesos a, b, c todos iguales a 1
  return(z)
}
```

```{r}
indices.list = list(Euclidea = EUC.DIST, #distancia euclidea [0,inf)
                    DTW = DTW.DIST, #dynamic time warping [0,inf)
                    SSIMT = SSIMT, #ssimt [-1,1] 
                    CHOU = CHOU.DIST, #Chouarkia con distancia euclidea [0,inf)
                    Mahalanobis = MahalanobisDist)
```

# Contaminación

Definimos qué tipos de contaminación vamos a utlizar para evaluar la robustéz de los índices.

Corresponde aclarar que en los casos de contaminaciones que presentan una longitud distinta en la serie de tiempo, para poder evaluar la similitud lo que hacemos es recortar la serie más larga a la longitud de la más corta.

```{r}
noise.list = list(AmpScaling = AmpSca, #escalado de la amplitud
                  AmpShift = AmpShift, #desplazamiento de la amplitud
                  TimeSca = TimeSca, #escalado del tiempo
                  TimeShift = TimeShift, #desplazamiento del tiempo
                  GaussNoise = GaussNoise, #ruido aditivo gaussiano
                  SaltPepper = TS.SaltPepper) #sal y pimienta
```

# El Experimento

## Primera parte. Entre diferentes índices.

```{r, message=FALSE, warning=FALSE, results='hide', include=FALSE}
grados = 10 #grados de contaminación
df.result = data.frame(stringsAsFactors=FALSE) #incializamos un dataframe para resultados

for (d in 1:length(df.list)) {
  #Seleccionamos el dataset
  DF = df.list[[d]]
  
  for (s in 1:dim(DF)[1]) {
    #Seleccionamos la serie a contaminar
    S1 = ts(as.numeric(DF[s,]))
    
    caso = paste0(d,".",s) #identificación del caso
    
    for (n in 1:length(noise.list)) {
      #seleccionamos la contaminación
      NOISE = noise.list[[n]]
      
      for (g in 1:grados) {
        #contaminamos la serie
        ifelse(names(noise.list[n])=="SaltPepper", gg <- (g*10/200), gg <- g)
        S2 = NOISE(S1, gg) 
        
        S1.2 = ts(S1[1:(sum(!is.na(S2)))])
        S2.2 = ts(na.omit(S2))
        
        for (i in 1:length(indices.list)) {
          #Seleccionamos el índice
          FUN = indices.list[[i]]
          
          #calculamos la similitud
          sim = FUN(S1.2, S2.2)
          #Identificamos y guuardamos
          dftoappend = cbind(caso, #código de identificacipon: dataset.serie
                             names(df.list)[d], #dataset 
                             names(noise.list)[n], #tipo de contaminación
                             g, #grado de contaminación
                             names(indices.list)[i], #índice utilizado
                             sim) #valor de similitud
          colnames(dftoappend) = c("Caso", "Dataset", "Contaminación", 
                                   "Grado","Índice", "Similitud")
          df.result = rbind(df.result, dftoappend)
        }
        
      }
    }
  }
}

```


# Plots

```{r}
dataset = names(df.list)[1]
sub1 = subset(df.result, Dataset==dataset)
ggplot(sub1, aes(x=as.numeric(Grado), y=as.numeric(Similitud), color=Caso))+
  geom_line() +
  facet_grid(Índice ~ Contaminación, scales="free")+
  #facet_wrap(~Contaminación + Dataset)+
  theme(legend.position = 'none')+
  scale_x_continuous(breaks=seq(0,10,1))+
  labs(title = dataset)
```

```{r}
dataset = names(df.list)[2]
sub1 = subset(df.result, Dataset==dataset)
ggplot(sub1, aes(x=as.numeric(Grado), y=as.numeric(Similitud), color=Caso))+
  geom_line() +
  facet_grid(Índice ~ Contaminación, scales="free")+
  #facet_wrap(~Contaminación + Dataset)+
  theme(legend.position = 'none')+
  scale_x_continuous(breaks=seq(0,10,1))+
  labs(title = dataset)
```

```{r}
dataset = names(df.list)[3]
sub1 = subset(df.result, Dataset==dataset)
ggplot(sub1, aes(x=as.numeric(Grado), y=as.numeric(Similitud), color=Caso))+
  geom_line() +
  facet_grid(Índice ~ Contaminación, scales="free")+
  #facet_wrap(~Contaminación + Dataset)+
  theme(legend.position = 'none')+
  scale_x_continuous(breaks=seq(0,10,1))+
  labs(title = dataset)
```

## Segunda parte. Entre diferentes índices.

# Distancias

Definimos qué distancias vamos a comparar y los cargamos también en una lista.

```{r}
Frechet.Dist <- function(x,y){return(Frechet(as.matrix(x),as.matrix(y)))}
CosineDist <- function(x,y){return(cosine_dist(as.numeric(x),as.numeric(y),testNA = FALSE))}
ChebyshevDist <- function(x,y){return(chebyshev(as.numeric(x),as.numeric(y),testNA = FALSE))}
EuclideanDist <- function(x,y){return(euclidean(as.numeric(x),as.numeric(y),testNA = FALSE))}
ManhattanDist <- function(x,y){return(manhattan(as.numeric(x),as.numeric(y),testNA = FALSE))}

distances.list = list(#Frechet = Frechet,
                      Coseno = CosineDist,
                      Mahalanobis = MahalanobisDist,
                      Chebyshev = ChebyshevDist,
                      Euclidean = EuclideanDist,
                      Manhattan = ManhattanDist)

```

```{r, message=FALSE, warning=FALSE, results='hide', include=FALSE}
grados = 10 #grados de contaminación
df.result2 = data.frame(stringsAsFactors=FALSE) #incializamos un dataframe para resultados

for (d in 1:length(df.list)) {
  #Seleccionamos el dataset
  DF = df.list[[d]]
  
  for (s in 1:dim(DF)[1]) {
    #Seleccionamos la serie a contaminar
    S1 = ts(as.numeric(DF[s,]))
    
    caso = paste0(d,".",s) #identificación del caso
    
    for (n in 1:length(noise.list)) {
      #seleccionamos la contaminación
      NOISE = noise.list[[n]]
      
      for (g in 1:grados) {
        #contaminamos la serie
        ifelse(names(noise.list[n])=="SaltPepper", gg <- (g*10/200), gg <- g)
        S2 = NOISE(S1, gg) 
        
        S1.2 = as.matrix(S1[1:(sum(!is.na(S2)))])
        S2.2 = as.matrix(na.omit(S2))
        print("series contaminadas")
        
        for (i in 1:length(distances.list)) {
          #Seleccionamos el índice
          FUN = distances.list[[i]]
          
          #calculamos la similitud
          sim = FUN(S1.2, S2.2)
          print(paste(d,i))
          #Identificamos y guuardamos
          dftoappend = cbind(caso, #código de identificacipon: dataset.serie
                             names(df.list)[d], #dataset 
                             names(noise.list)[n], #tipo de contaminación
                             g, #grado de contaminación
                             names(distances.list)[i], #índice utilizado
                             sim) #valor de similitud
          colnames(dftoappend) = c("Caso", "Dataset", "Contaminación", 
                                   "Grado","Índice", "Similitud")
          df.result2 = rbind(df.result2, dftoappend)
        }
        
      }
    }
  }
}

```




```{r}
dataset = names(df.list)[1]
sub1 = subset(df.result2, Dataset==dataset)
ggplot(sub1, aes(x=as.numeric(Grado), y=as.numeric(Similitud), color=Caso))+
  geom_line() +
  facet_grid(Índice ~ Contaminación, scales="free")+
  #facet_wrap(~Contaminación + Dataset)+
  theme(legend.position = 'none')+
  scale_x_continuous(breaks=seq(0,10,1))+
  labs(title = dataset)
```

```{r}
dataset = names(df.list)[2]
sub1 = subset(df.result2, Dataset==dataset)
ggplot(sub1, aes(x=as.numeric(Grado), y=as.numeric(Similitud), color=Caso))+
  geom_line() +
  facet_grid(Índice ~ Contaminación, scales="free")+
  #facet_wrap(~Contaminación + Dataset)+
  theme(legend.position = 'none')+
  scale_x_continuous(breaks=seq(0,10,1))+
  labs(title = dataset)
```

```{r}
dataset = names(df.list)[3]
sub1 = subset(df.result2, Dataset==dataset)
ggplot(sub1, aes(x=as.numeric(Grado), y=as.numeric(Similitud), color=Caso))+
  geom_line() +
  facet_grid(Índice ~ Contaminación, scales="free")+
  #facet_wrap(~Contaminación + Dataset)+
  theme(legend.position = 'none')+
  scale_x_continuous(breaks=seq(0,10,1))+
  labs(title = dataset)
```